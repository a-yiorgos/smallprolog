/* help.spr */
/* information on predicates */
/* load this with (consult "help.spr") and then 
 * type (help) or (help My_predicate)
 */

((help)
 (info P Args Text See_also)
 (writes "***********************************")
 (nl)
 (display P)
 (nl)
 (help_builtin P)
 (help_args Args)
 (help_text Text)
 (help_see_also See_also)
 (nl)
 (pause)
 (fail)
)
(help)

((help P)
 (info P Args Text See_also)
 (help_builtin P)
 (help_args Args)
 (help_text Text)
 (help_see_also See_also)
)
((help_builtin P)
 (builtin P)
 (cut)
 (display P)
 (writes " is a builtin.")
 (nl)
)
(help_builtin _)

((help_args Args)
 (writes "Expected argument types: ")
 (nl)
 (help_args1 Args)
 (nl)
)
((help_args1 (()))
 (cut)
)
((help_args1 (X))
 (atom X)
 (cut)
 (writes "Variable number of ")
 (display X)
 (nl)
)
((help_args1 (Head))
 (cut)
 (help_args2 Head)
 (nl)
)
((help_args1 (Head | Tail))
 (help_args2 Head)
 (nl)
 (writes "then")
 (nl)
 (help_args1 Tail)
)
(help_args1 ())

((help_args2 (X))
 (display X)
 (cut)
)
((help_args2 (First | Rest))
 (display First)
 (writes " or ")
 (help_args2 Rest)
)

((help_text (Head | Tail))
 (cut)
 (writes Head)
 (nl)
 (help_text Tail)
)
(help_text ())

((help_see_also L)
 (nl)
 (writes "See also: ")
 (help_see_also1 L)
)
((help_see_also1 (H | T))
 (cut)
 (display H)
 (writes " ")
 (help_see_also1 T)
)
(help_see_also1 ())

((pause )
 (nl)(writes "Press Return for more..")
 (get X)
 (pause_action X)
)

((pause_action 113)(cut)(abort))/* ie typing a q causes the program to end */
((pause_action _))

(info tell ((string))
	("Redirects current output stream to file."
	 "the file ""user"" represents the console"
	)
	(told telling)
)
(info telling ((variable string))
	("Unifies argument with name of current output stream.")
	(told tell)
)
(info told ()
	("Closes current output stream if different from console.")
	(tell telling)
)
(info display ((anything))
	("Writes first argument on current output stream."
	"Default current output stream is console.")
	(writes put nl)
)
(info display ((anything) (variable integer ))
	("Writes first argument on current output stream."
	"Default current output stream is console."
	"Unifies second argument with number of chars output.")
	(writes put nl)
)
(info writes ((string))
	("Writes without inverted commas the string to current output stream.")
	(display nl put)
)
(info nl (())
	("Writes a newline on current output stream.")
	(display writes put)
)
(info put ((integer))
	("Displays a character whose ascii code is the integer.") 
	(display writes nl)
)
(info see ((string))
	("Current input stream becomes argument which is a file name.")
	(seeing seen)
)
(info consult ((string atom))
	("Loads named file adds it to current work space."
	 "Does not remove existing clauses."
	)
        ()
)
(info seeing ((string variable))
	("Unifies argument with name of current input stream.")
	(see seen)
)
(info seen ()
	("Closes current input stream if different from console.")
	(see seeing)
)
(info read ((anything))
	("Reads next (full) prolog term in input stream."
	 "Unifies this with argument."
	)
	(read_word get)
)
(info read_word ((variable string))
	("Reads next sequence of consecutive non blank characters."
	 "Unifies string thus formed with argument.")
	(read get)
)
(info get ((variable integer))
	("Reads ascii code of next character and unifies it with argument.")
	(read_word read)
)
(info atomic ((anything))
	("Suceeds if argument is atom or integer or string or real.")
	(atom)
)
(info integer ((anything))
	("Succeeds if argument type is integer.")
	(atom string atomic)
)
(info string ((anything))
	("Succeeds if argument type is string.")
	(atom integer atomic )
)

/* not implemented
(info real ((anthing))
	("Succeeds if argument type is real.")
	(atom integer)
)
*/
(info atom ((anything))
	("Succeeds if argument type is atom.")
	(integer string atomic)
)
(info var ((anything))
	("Succeeds if argument is a variable.")
	(nonvar)
)
(info nonvar ((anything))
	("Succeeds if argument is not a variable.")
	(var)
)
(info builtin ((atom))
	("Succeeds if aargument is name of builtin.")
)
(info abort (())
	("Terminates execution of current query.")
	(quit)
)
(info quit (())
	("Terminates current session.")
	(abort)
)
(info statistics (())
	("Displays space left in workspace.")
	( space_left n_unifications)
)
(info space_left ((var)(var)(var)(var)(var)(var))
	("Used by statistics.")
	(statistics n_unifications)
)
(info n_unifications ((integer variable))
	("Unifies argument with number of unifications performed in session.")
	(statistics)
)
(info iplus ((integer)(integer)(variable integer))
	("Unifies third argument with sum of first two.")
	(iminus imult)
)
(info iminus ((integer)(integer)(variable integer))
	("Unifies third argument with difference of first two.")
	(iminus imult)
)
(info imult ((integer)(integer)(variable integer))
	("Unifies third argument with product of first two.")
	(iminus imult)
)
(info iless ((integer)(integer))
	("Suceeds if first argument is less than second.")
	(rless)
)
(info ileq ((integer)(integer))
	("Suceeds if first argument is less than or equal to second.")
	(iless)
)
(info rless ((real)(real))
	("Suceeds if first argument is less than second.")
	(iless)
)
(info rplus ((real)(real)(variable real))
	("Unifies 3rd argument with sum of first two.")
	(iplus)
)
(info var_offset ((var)(var integer))
	("Unifies 2nd argument with occurence index of first argument."
	 "This is special, see xread.spr.")
	(var_name)
)
(info var_name ((var)(var string))
	("Unifies 2nd argument with name of first argument."
	 "This must be called just after a parse."
	 "This is a special predicate, see xread.spr."
	)
	(var_offset)
)
(info clean_temp (())
	("Clears the temporary zone.")
	(statistics temp_asserta temp_assertz)
)
(info asserta ((list))
	("Adds a new clause corresponding to first argument."
	 "The clause becomes the first of its predicate."
	)
	(assertz temp_asserta temp_assertz remove_clause)
)
(info asserta ((list)(integer))
	("Adds a new clause corresponding to first argument."
	 "Tries to make the clause the nth of its predicate "
	 "where n is the value of the second argument.")
	(assertz temp_asserta temp_assertz remove_clause)
)
(info temp_asserta ((list))
	("Adds a new clause corresponding to first argument."
	 "The clause becomes the first of its predicate."
	 "The clause is put in the temporary zone."
	)
	(assertz temp_asserta temp_assertz remove_clause clean_temp)
)
(info temp_asserta ((list)(integer))
	("Adds a new clause corresponding to first argument."
	 "The clause is put in the temporary zone."
	 "Tries to make the clause the nth of its predicate "
	 "where n is the value of the second argument.")
	(assertz temp_asserta temp_assertz remove_clause)
)
(info assertz ((list))
	("Adds a new clause corresponding to first argument."
	 "The clause becomes the last of its predicate."
	)
	(asserta temp_asserta temp_assertz remove_clause)
)
(info temp_assertz ((list))
	("Adds a new clause corresponding to first argument."
	 "The clause becomes the last of its predicate."
	 "The clause is put in the temporary zone."
	)
	(asserta temp_asserta assertz remove_clause clean_temp)
)
(info remove_clause ((clause))
	("Removes the clause."
	 "Dont put a list as an argument!"
	)
	(first_clause next_clause body_clause clause retract)
)
(info first_clause ((atom)(variable))
	("Unifies the 2nd argument with the 1st clause of first argument.")
	(next_clause)
)
(info next_clause ((clause)(variable))
	("Unifies the 2nd argument with the clause following first argument.")
	(first_clause)
)
(info body_clause ((clause)(list variable))
	("Unifies the 2nd argument with the body of the 1st argument.")
	(first_clause predicate)
)
(info string_from ((anything)(string variable))
	("Tries to unify 2nd argument with string representation of "
	 "first argument.")
	(string_length interned)
)
(info interned ((string)(variable))
	("Succeeds if string has corresponding atom."
	 "Unifies the variable with the atom in this case."
 	)
	(string_from)
)
(info string_length ((string)(variable integer))
	("Unifies 2nd argument with length of first argument.")
	(string_nth)
)
(info string_nth ((integer)(string)(variable integer))
	("Unifies 3rd argument with ascii code of nth char of 2nd argument.")
	(string_length)
)
(info string_concat ((string)(string)(variable string))
	("Unifies 3rd argument with concatenation of the first two arguments.")
	(string_length string_nth)
)
(info string_suffix ((integer)(string)(string variable))
	("Unifies 3rd argument with rest of string of first string "
	"from nth character on -where n is the value of first argument.")
	(string concat)
)
(info rand ((integer variable)(integer))
	("Unifies first argument with a pseudo-random integer "
	 "less than second argument."
 	"Not very random (not my fault!)."
	)
	()
)

(info listing (())
	("Displays all clauses in workspace.")
	(statistics logging)
)
(info  listing ((atom))
	("Displays all clauses correponding to argument.")
	(statistics)
)
(info fail (())
	("The recommended way of deliberately failing")
	()
)
(info repeat (())
	("Create a backtrack point that never stops")
	(fail cut)
)

(info gennum ((variable integer)(integer))
	("Unify 1st argument with integers from 0 to 2nd argument"
	 "through backtracking (try (gennum X 3))"
	)
	(fail cut)
)

(info logging ((string))
	("Records the session from then on to named file.")
	(nologging)
)
(info nologging (())
	("Stops logging the session.")
	(logging)
)

(info not ((list))
	("Succeeds iff argument fails as goal.")
	(diff)
)
(info diff ((anything)(anything))
	("Succeeds if arguments are different."
	 "Arguments should not have variables."
	)
	(not)
)
(info eq ((anything)(anything))
	("Suceeds if arguments can be unified."
	 "Most beginners use this where they need not.")
	(diff)
)
(info member ((anything)(list))
	("succeeds if 1st argument can be unified with a member of 2nd argument.")
	(append)
)
(info append ((list variable)(list variable)(list variable))
	("Succeeds if you can unify the concatenation of the first 2 arguments"
	 "with the third argument")
	(member)
)
(info all_facts ((list)(variable list))
	("Unifies 2nd argument with list of all facts "
	 "having same predicate as 1st argument."
	"Can be an alternative to findall."
	)
	(findall)
)
(info findall ((variable list)(list)(variable list))
	("Unifies 3rd argument with list of all elements matching"
	 "first argument such that second argument succeeds as goal."
	 "Not space efficient due to lack of garbage collector."
	 "See example file.")
	(all_facts)
)
(info clause ((list)(list))
	("Unifies 1st argument with head of existing clauses "
	 "and 2nd argument with conditions of corresponding clause.")
	(predicate)
)
(info predicate ((atom variable))
	("Unifies 1st argument with non-builtin predicates.")
	(builtin)
)
(info retract ((list))
	("Removes fact corresponding to list."
	 "Can backtrack, removing all such facts."
	)
	(remove_clause)
)
(info and (list)
	("This has a variable number of arguments."
	 "Only Micro-prolog and Small Prolog give you this."
	 "Succeeds if all arguments succeed as goals."
	 "Useful in intricate logical expressions."
	)
	(or)
)
(info or (list)
	("This has a variable number of arguments."
	 "Only Micro-prolog and Small Prolog give you this."
	 "Succeeds if one of the arguments succeeds as a goal."
	 "Useful in intricate logical expressions."
	)
	(or)
)
(info cut (())
	("Stop looking for solutions of parent goal."
 	 "See any good book for more."
	)
	(fail)
)
(info trace (())
	("Turns tracing mode on.")
	(notrace suspend_trace resume_trace)
)
(info notrace (())
	("Turns tracing mode off.")
	(trace suspend_trace resume_trace)
)
(info reverse_trace_mode (())
	("Turns reverse tracing mode on."
	 "this does not turn tracing on by its own"
	 "but it is necessary it you want to be able to reverse trace"
	)
	(trace notrace suspend_trace resume_trace no_reverse_trace_mode)
)
(info no_reverse_trace_mode (())
	("Turns reverse tracing mode off."
	 "This reverts the system back to the default mode."
	)
	(trace notrace suspend_trace resume_trace reverse_trace_mode)
)
(info suspend_trace (())
	("Decrements the trace_flag that is responsible for tracing."
	 "This is useful in the bodies of rules whose executions you trust.")
 	(resume_trace trace notrace)
)
(info resume_trace (())
	("Increments the trace_flag that is responsible for tracing.")
 	(suspend_trace trace notrace )
)
